<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>源码 on Feng Zhenbing's Blog</title><link>https://fengzhenbing.github.io/categories/%E6%BA%90%E7%A0%81/</link><description>Recent content in 源码 on Feng Zhenbing's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 05 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://fengzhenbing.github.io/categories/%E6%BA%90%E7%A0%81/index.xml" rel="self" type="application/rss+xml"/><item><title>shardingsphere（5.0.0.beta）元数据上下文</title><link>https://fengzhenbing.github.io/p/shardingsphere5.0.0.beta%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/</link><pubDate>Sun, 05 Sep 2021 00:00:00 +0000</pubDate><guid>https://fengzhenbing.github.io/p/shardingsphere5.0.0.beta%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/</guid><description>Shardingsphere（5.0.0.beta）源码学习-元数据上下文 上下文对象 上下文对象作为读取并解析配置, 承载数据的核心；
spring有ApplicationContext,netty有HandlerContext
向其他中间件一样，在ShardingSphere也十分重要; 后续几乎所有功能比如数据分片、数据加密、SQL 改写，各类扩展都依赖上下文对象存储的数据
标准元数据上下文 StandardMetaDataContexts 核心存储了ShardingSphereMetaData元数据集合，作为重点后面分析
@Getter public final class StandardMetaDataContexts implements MetaDataContexts { // 元数据集合 private final Map&amp;lt;String, ShardingSphereMetaData&amp;gt; metaDataMap; private final ShardingSphereRuleMetaData globalRuleMetaData; // 执行引擎 private final ExecutorEngine executorEngine; //优化引擎上下文工厂 private final OptimizeContextFactory optimizeContextFactory; private final ConfigurationProperties props; // 状态上下文 private final StateContext stateContext; ... } 治理元数据上下文 StandardMetaDataContexts 其实也是用的标准的StandardMetaDataContexts，治理模块shardingsphere-governance使用该上下文，通过配置中心读取规则配置，
注入到StandardMetaDataContexts中，GovernanceFacade是配置中心的门面模式，目前支持了zookeeper和etcd,其实还可以通过RegistryCenterRepository的spi实现其他的配置中心，比如nacos, apollo,consul等。
public final class GovernanceMetaDataContexts implements MetaDataContexts { //治理： 配置中心的门面模式 private final GovernanceFacade governanceFacade; //还是使用StandardMetaDataContexts 装饰器模式 private volatile StandardMetaDataContexts metaDataContexts; private final ShardingSphereLock lock; .</description></item><item><title>shardingsphere（5.0.0.beta）源码总览</title><link>https://fengzhenbing.github.io/p/shardingsphere5.0.0.beta%E6%BA%90%E7%A0%81%E6%80%BB%E8%A7%88/</link><pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate><guid>https://fengzhenbing.github.io/p/shardingsphere5.0.0.beta%E6%BA%90%E7%A0%81%E6%80%BB%E8%A7%88/</guid><description>Shardingsphere（5.0.0.beta）源码学习-总览 shardingsphere作为极为优秀的开源分布式数据库解决方案，通过阅读源码可以学到很多软件设计与开发的知识。
本次我继续按照之前读源码的方式从整体到细节，带着问题读源码的方式记录这次深入学习 shardingsphere的过程。
源码版本 5.0.0.beta 官方文档 源码地址 https://github.com/apache/shardingsphere/tree/5.0.0-beta 项目结构 先大概理解各个模块的主要功能点
一级目录 说明 examples 各种使用例子 shardingsphere-agent 监控, 对接apm,链路追踪 shardingsphere-db-protocol 数据库协议 shardingsphere-distribution 相关打包发步用 shardingsphere-distsql-parser distsql新功能:ShardingSphere 特有的内置 SQL 语言，提供了标准 SQL 之外的增量功能操作能力。 shardingsphere-features 常用功能shardingsphere-db-discovery 基于MGR主从切换的功能shardingsphere-encrypt 加解密shardingsphere-readwrite-splitting 读写分离 **重点**shardingsphere-shadow 影子库shardingsphere-sharding 分库分表 **重点** shardingsphere-governance 数据治理：结合注册中心，提供给前端页面使用 shardingsphere-infra 引擎内核：shardingsphere-infra-authority proxy的权限控制shardingsphere-infra-binder sql解析后的结果绑定封装SQLStatement封装为各类上下文contextshardingsphere-infra-common 重要的实体类及工具 的元数据metadata,SPI,yaml工具，rule接口等shardingsphere-infra-context 上下文相关shardingsphere-infra-datetime 时间服务shardingsphere-infra-executor 执行器引擎 **重点**shardingsphere-infra-merge 归并引擎**重点**shardingsphere-infra-optimize 优化引擎**重点**shardingsphere-infra-parser 解析引擎**重点**shardingsphere-infra-rewrite 改写引擎**重点**shardingsphere-infra-route 路由引擎**重点** shardingsphere-jdbc jdbc核心功能：增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。装饰器模式，对原生的DataSource,Connection,Statement(PrepareStatement),ResultSet进行包装， shardingsphere-proxy 透明化的数据库代理提供封装了数据库二进制协议的服务端版本，用于完成对异构语言的支持 shardingsphere-scaling 数据迁移相关:弹性伸缩 shardingsphere-sql-parser sql解析器：antlr4 词法语法解析出SqlStatement,提供各类数据库的方言实现。SQL 解析作为分库分表类产品的核心，其性能和兼容性是最重要的衡量指标 shardingsphere-test 测试引擎 shardingsphere-transaction 事务：整合现有的成熟事务方案，本地事务、两阶段事务（XA）和柔性事务（Seata AT 事务）提供统一的分布式事务接口 对于重点核心内容有个大致认识，后面再单独分模块分析。</description></item><item><title>分布式任务调度Hodor</title><link>https://fengzhenbing.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6hodor/</link><pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate><guid>https://fengzhenbing.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6hodor/</guid><description>分布式任务调度Hodor源码分析（整体结构） 简介 Hodor是一个高性能的分布式任务调度框架。
github地址(https://github.com/tincopper/hodor)
架构图 因无任何文档，以下架构图纯阅读源码个人理解后手工所画：
代码目录及分析 hodor-admin
待开发：配合前端页面做任务展示
hodor-client
客户端，用户app通过该客户端将任务信息提交到hodor-server，供其调度
集成了nettyserver服务，接收来自hodor-server的任务执行请求
hodor-client-demo
用户app示例：集成了hodor-client
hodor-common
通用库
环形队列 观察者模式（事件发布监听）模型 Excutor：多线程封装 Extension: SPI扩展方式封装 负载均衡 存储：本地缓存/mysql/h2 异常 日志 Distributor高性能队列 hodor-core
简单的spring mybatis 工程：对任务/任务执行记录等数据入库（mysql）
hodor-extension
hodor-model
实体
hodor-register
注册中心封装，目前只实现了zookeeper
hodor-register-api Hodor-register-zookeeper hodor-remoting
netty http客户端
netty http服务端
hodor-scheduler
任务定时的封装</description></item><item><title>01.gateway整体逻辑</title><link>https://fengzhenbing.github.io/p/01.gateway%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/p/01.gateway%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91/</guid><description>gateway整体逻辑 1.流程图 2.几个关键的类 org.springframework.web.reactive.DispatcherHandler: 请求分发处理器； Spring WebFlux 的访问入口； 类似于spring mvc DispatcherServlet,可以类比spring mvc 接收到请求; DispatcherHandler匹配 HandlerMapping此处会匹配到scg的RoutePredicateHandlerMapping org.springframework.cloud.gateway.handler.RoutePredicateHandlerMapping：HandlerMapping的实现；
通过RouteLocator匹配 Route: getHandlerInternal方法调用lookupRoute()方法，通过routeLocator获取所有配置的route,通过里面的Predicate配置来遍历判断找出符合的Route getHandlerInternal中返回FilteringWebHandler org.springframework.cloud.gateway.handler.FilteringWebHandler: WebHandler的实现；
FilteringWebHandler被RoutePredicateHandlerMapping返回后，在DispatcherHandler中被SimpleHandlerAdapter执行handle方法； 责任链模式：获取Route的GatewayFilter数组，创建DefaultGatewayFilterChain的过滤链；链式调用GatewayFilter 3.项目结构 核心module为spring-cloud-gateway-server
actuate: 实现springboot actuator的端点，暴露route filter predicate等信息 config: 使用springboot的配置注解的各类配置类 discover：通过注册中心获取路由Route的核心功能配置类及实现类 event：实现ApplicationEvent的事件类，例如路由刷新事件RefreshRoutesEvent filter: 包含特定路由的GatewayFilterFactory，GatewayFiler以及全局的GlobalFilter handler: 包含匹配route的断言工厂AbstractRoutePredicateFactory的所有默认实现，以及核心类FilteringWebHandler及RoutePredicateHandlerMapping route：路由的定义类，及路由定位类CachingRouteLocator的所有实现，及路由定义定位类CompositeRouteDefinitionLocator的所有实现，路由存储接口RouteDefinitionRepository及其所有实现 support：工具类；如HTTP协议处理，组件名处理，日期转换等</description></item><item><title>02.reactor响应式编程学习</title><link>https://fengzhenbing.github.io/p/02.reactor%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/p/02.reactor%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/</guid><description>reactor 使用 ![image (1)](https://fengzhenbing.github.io/img/picgo/image (1).png)
Webflux 模块的名称是 spring-webflux，名称中的 Flux 来源于 Reactor 中的类 Flux。 Reactor 两个核心概念做一些澄清，一个是Mono，另一个是Flux
Flux ：表示的是包含 0 到 N 个元素的异步序列。包含三个类型 正常的包含元素的消息 序列结束的消息 序列出错的消息 Mono： 表示的是包含 0 或者 1 个元素的异步序列。该序列中同样可以包含与 Flux 相同的三种类型的消息通知。 示例代码： https://github.com/fengzhenbing/spring-cloud-gateway-demo/blob/master/demo-gateway/src/main/java/org/fzb/demo/gateway/RectorController.java</description></item><item><title>03.scg NettyWebServer启动过程</title><link>https://fengzhenbing.github.io/p/03.scg-nettywebserver%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/p/03.scg-nettywebserver%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</guid><description>scg NettyWebServer启动过程 spring cloud gateway(下面简称scg)依赖spring webflux, 而spring webflux依赖于reactor-netty,也就是scg启动过程中最终会启动netty做为服务器。 springboot中定义一下几种服务器：
1 启动ReactiveWebServerApplicationContext 从springboot启动开始分析
SpringApplication.run(GatewayApplication.class, args); 设置webApplicationType的值：REACTIVE还是servlet的。
public SpringApplication(ResourceLoader resourceLoader, Class&amp;lt;?&amp;gt;... primarySources) { this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &amp;#34;PrimarySources must not be null&amp;#34;); this.primarySources = new LinkedHashSet&amp;lt;&amp;gt;(Arrays.asList(primarySources)); this.webApplicationType = WebApplicationType.deduceFromClasspath();//fzb 通过类路径中类，推测web应用类型：REACTIVE还是servlet的。 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = deduceMainApplicationClass(); } 再看deduceFromClasspath方法：判断DispatcherHandler存在还是DispatcherServlet存在
static WebApplicationType deduceFromClasspath() {//fzb 判断DispatcherHandler存在还是DispatcherServlet存在 if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) &amp;amp;&amp;amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null) &amp;amp;&amp;amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) { return WebApplicationType.REACTIVE; } for (String className : SERVLET_INDICATOR_CLASSES) { if (!</description></item><item><title>04.scg 一次请求的执行过程</title><link>https://fengzhenbing.github.io/p/04.scg-%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/p/04.scg-%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</guid><description>一次请求的执行过程</description></item><item><title>05.route路由的配置加载</title><link>https://fengzhenbing.github.io/p/05.route%E8%B7%AF%E7%94%B1%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/p/05.route%E8%B7%AF%E7%94%B1%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD/</guid><description>route路由的配置加载 主要在sprng-cloud-gateway-server的route包定义路由相关的定义，构建和加载
![路由](https://fengzhenbing.github.io/img/picgo/image (2).png)
0.相关配置 通过springboot spi方式，springboot会启动spring.factories中配置的 org.springframework.cloud.gateway.discovery.GatewayDiscoveryClientAutoConfiguration org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ org.springframework.cloud.gateway.config.GatewayAutoConfiguration,\ org.springframework.cloud.gateway.discovery.GatewayDiscoveryClientAutoConfiguration,\ ... 1.路由定义 路由定义RouteDefinition public class RouteDefinition { private String id; @NotEmpty @Valid//fzb 断言定义数组 private List&amp;lt;PredicateDefinition&amp;gt; predicates = new ArrayList&amp;lt;&amp;gt;(); @Valid//fzb 过滤器定义数组 private List&amp;lt;FilterDefinition&amp;gt; filters = new ArrayList&amp;lt;&amp;gt;(); @NotNull//fzb 路由路径 private URI uri; ... } 路由定义定位器 获取路由的定义，负责读取上述路由定义配置 RouteDefinition，最终会通过路由定义生成路由
public interface RouteDefinitionLocator { //fzb 获取路由定义对象 Flux&amp;lt;RouteDefinition&amp;gt; getRouteDefinitions(); } 有以下实现：
![image (3)](https://fengzhenbing.</description></item><item><title>06.route通过注册中心自动配置加载</title><link>https://fengzhenbing.github.io/p/06.route%E9%80%9A%E8%BF%87%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/p/06.route%E9%80%9A%E8%BF%87%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD/</guid><description>route通过注册中心Eureka自动加载配置 配置 gateway及后端微服务引入注册中心客户端eureka-client &amp;lt;!-- 引入 Spring Cloud Netflix Eureka Client 相关依赖，将 Eureka 作为注册中心的客户端，并实现对其的自动配置 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; eureka-client starter的引入，会同时引入ribbon,作为后续请求，负载均衡的实现 spring.cloud.gateway.discovery.locator.enabled设为true,启用服务发现的DiscoveryClientRouteDefinitionLocator
spring:cloud:# Spring Cloud Gateway 配置项，对应 GatewayProperties 类gateway:discovery:locator:enabled:true# default fase，设为true开启@Configuration(proxyBeanMethods = false) @ConditionalOnProperty(value = &amp;#34;spring.cloud.discovery.reactive.enabled&amp;#34;,//fzb 默认使用响应式的方式 matchIfMissing = true) public static class ReactiveDiscoveryClientRouteDefinitionLocatorConfiguration { @Bean//fzb spring.cloud.gateway.discovery.locator.enabled配为true时，才开启DiscoveryClientRouteDefinitionLocator @ConditionalOnProperty(name = &amp;#34;spring.cloud.gateway.discovery.locator.enabled&amp;#34;) public DiscoveryClientRouteDefinitionLocator discoveryClientRouteDefinitionLocator( ReactiveDiscoveryClient discoveryClient,//响应式的客服端 Eureka就是 EurekaReactiveDiscoveryClient DiscoveryLocatorProperties properties) { return new DiscoveryClientRouteDefinitionLocator(discoveryClient, properties); } } eureka-client的引入，会开启TimedSupervisorTask执行HeartbeatThread的心跳任务， 默认每隔30s一次 RouteRefreshListener 每隔30s接收到HeartBeatEvent事件，同时会发送RefreshRoutes事件</description></item><item><title>07.precidate的对路由进行选择</title><link>https://fengzhenbing.github.io/p/07.precidate%E7%9A%84%E5%AF%B9%E8%B7%AF%E7%94%B1%E8%BF%9B%E8%A1%8C%E9%80%89%E6%8B%A9/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/p/07.precidate%E7%9A%84%E5%AF%B9%E8%B7%AF%E7%94%B1%E8%BF%9B%E8%A1%8C%E9%80%89%E6%8B%A9/</guid><description>precidate选择路由</description></item><item><title>08.filter的配置加载及合并</title><link>https://fengzhenbing.github.io/p/08.filter%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%90%88%E5%B9%B6/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/p/08.filter%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%90%88%E5%B9%B6/</guid><description/></item></channel></rss>