<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JVM on Feng Zhenbing's Blog</title><link>https://fengzhenbing.github.io/categories/jvm/</link><description>Recent content in JVM on Feng Zhenbing's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 15 Aug 2021 14:16:25 +0600</lastBuildDate><atom:link href="https://fengzhenbing.github.io/categories/jvm/index.xml" rel="self" type="application/rss+xml"/><item><title>Prometheus监控JVM</title><link>https://fengzhenbing.github.io/p/prometheus%E7%9B%91%E6%8E%A7jvm/</link><pubDate>Sun, 15 Aug 2021 14:16:25 +0600</pubDate><guid>https://fengzhenbing.github.io/p/prometheus%E7%9B%91%E6%8E%A7jvm/</guid><description>1. jmx_exporter 下载jmx_exporter ubuntu:/# mkdir -p /usr/local/prometheus/jmx_exporter ubuntu:/# cd /usr/local/prometheus/jmx_exporter ubuntu:/# wget https://repo1.maven.org/maven2/io/prometheus/jmx/jmx_prometheus_javaagent/0.16.1/jmx_prometheus_javaagent-0.16.1.jar 配置文件jmx_exporter jmx_exporter.yml
vim /usr/local/prometheus/jmx_exporter/jmx_exporter.yml --- rules: - pattern: &amp;quot;.*&amp;quot; java agent运行jmx_exporter 以java agent的方式启动你的一个java应用
java -javaagent:/usr/local/prometheus/jmx_prometheus_javaagent-0.16.1.jar=3010:/usr/local/prometheus/jmx_exporter.yml -jar xxx-web-0.1-SNAPSHOT.jar 2. prometheus docker方式下载运行 # docker pull prom/prometheus #下载docker镜像 # mkdir -p /etc/prometheus # vim /etc/prometheus/prometheus.yml #配置 # docker run -d \ -p 192.168.3.13:9090:9090 \ -v /etc/prometheus:/etc/prometheus \ prom/prometheus; prometheus中配置上步的jmx的metrics global:scrape_interval:15sscrape_timeout:10sevaluation_interval:15salerting:alertmanagers:- follow_redirects:truescheme:httptimeout:10sapi_version:v2static_configs:- targets:[]scrape_configs:- job_name:prometheushonor_timestamps:truescrape_interval:15sscrape_timeout:10smetrics_path:/metricsscheme:httpfollow_redirects:truestatic_configs:- targets:- 192.168.3.13:9090### 以下为jmx_exporter地址：需改为你实际的- job_name:&amp;#39;jmx&amp;#39;static_configs:scrape_interval:15s- targets:[&amp;#39;192.</description></item><item><title>jvm垃圾回收</title><link>https://fengzhenbing.github.io/p/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Sun, 14 Mar 2021 00:00:00 +0000</pubDate><guid>https://fengzhenbing.github.io/p/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>jvm垃圾回收 垃圾回收算法 针对 堆内存回收；
方法区：
java 8 前 永久区（也参与垃圾回收，一样的算法，省事了，但是有默认最大内存限制，容易oom）
java 8 彻底抛弃了 永久区，叫元数据区，使用本地内存
分代收集理论 新生代
老年代
跨代引用： Remember set
标记清除 产生内存碎片，内存分配复杂了。 可能需要类似硬盘的 “分区空闲分配链表” 等复杂方式解决
Cms搜集器在old 区回收时采用， 但是内存碎片达到一定量，会采取一次标记清理。（和稀泥的做法，结合两者，）
标记复制 一般用于新生代回收: Serial ParNew 的新生代采用该算法
Ēden scurvivor scurvivor 8:1:1
对象存活率较高时，需要更多的复制操作，效率会降低
标记整理 用于old区：
相对于 标记清除， 标记后，需要移动：将存活的对象移动到内存区域的一端。
移动：增大的延迟，stw时间长些，但解决了内存碎片，内存分配复杂的问题，可以提高吞吐量。
不移动：降低了延迟，但内存碎片，内存分配复杂， 吞吐量有所下降。
垃圾回收器</description></item></channel></rss>