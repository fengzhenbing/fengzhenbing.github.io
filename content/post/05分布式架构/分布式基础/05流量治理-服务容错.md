---
title: "test"
date: 2021-07-21
description: test
draft: true
tags:
    - test
categories:
    - test
    - 分布式
---



### 容错策略

面对故障，我们该做些什么

#### **故障转移**（Failover）

故障转移是指如果调用的服务器出现故障，系统不会立即向调用者返回失败结果，而是自动切换到其他服务副本，尝试其他副本能否返回成功调用的结果，从而保证了整体的高可用性。

需要具备幂等性

#### **快速失败**（Failfast）

不具备幂等性的坚决避免重试，尽快抛出异常，由调用者自行处理

比如银行扣款接口业务

#### **安全失败**（Failsafe）

服务通常也有主路和旁路（aop处理的一些非业务逻辑）之分，旁路逻辑调用实际失败了，也当作正确来返回，然后自动记录一条服务调用出错的日志备查即可，这种策略被称为安全失败。

#### **沉默失败**（Failsilent）

当请求失败后，就默认服务提供者一定时间内无法再对外提供服务，不再向它分配请求流量，将错误隔离开来，避免对系统其他部分产生影响，此即为沉默失败策略。

#### **故障恢复**（Failback）

重试任务

#### **并行调用**（Forking）

指一开始就同时向多个服务副本发起调用，只要有其中任何一个返回成功，那调用便宣告成功，这是一种在关键场景中使用更高的执行成本换取执行时间和成功概率的策略。

#### **广播调用**（Broadcast）

并行调用是任何一个调用结果返回成功便宣告成功，广播调用则是要求所有的请求全部都成功，这次调用才算是成功，任何一个服务提供者出现异常都算调用失败，广播调用通常会被用于实现“刷新分布式缓存”这类的操作。



| 容错策略     | 优点                                              | 缺点                                                         | 应用场景                                                |
| ------------ | ------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------- |
| **故障转移** | 系统自动处理，调用者对失败的信息不可见            | 增加调用时间，额外的资源开销                                 | 调用幂等服务 对调用时间不敏感的场景                     |
| **快速失败** | 调用者有对失败的处理完全控制权 不依赖服务的幂等性 | 调用者必须正确处理失败逻辑，如果一味只是对外抛异常，容易引起雪崩 | 调用非幂等的服务 超时阈值较低的场景                     |
| **安全失败** | 不影响主路逻辑                                    | 只适用于旁路调用                                             | 调用链中的旁路服务                                      |
| **沉默失败** | 控制错误不影响全局                                | 出错的地方将在一段时间类不可用                               | 频繁超时的服务                                          |
| **故障恢复** | 调用失败后自动重试，也不影响主路逻辑              | 重试任务可能产生堆积，重试仍然可能失败                       | 调用链中的旁路服务 对实时性要求不高的主路逻辑也可以使用 |
| **并行调用** | 尽可能在最短时间内获得最高的成功率                | 额外消耗机器资源，大部分调用可能都是无用功                   | 资源充足且对失败容忍度低的场景                          |
| **广播调用** | 支持同时对批量的服务提供者发起调用                | 资源消耗大，失败概率高                                       | 只适用于批量操作的场                                    |

### 容错设计模式

#### 断路器模式

- **CLOSED**：表示断路器关闭，此时的远程请求会真正发送给服务提供者。断路器刚刚建立时默认处于这种状态，此后将持续监视远程请求的数量和执行结果，决定是否要进入 OPEN 状态。
- **OPEN**：表示断路器开启，此时不会进行远程请求，直接给服务调用者返回调用失败的信息，以实现快速失败策略。
- **HALF OPEN**：这是一种中间状态。断路器必须带有自动的故障恢复能力，当进入 OPEN 状态一段时间以后，将“自动”（一般是由下一次请求而不是计时器触发的，所以这里自动带引号）切换到 HALF OPEN 状态。该状态下，会放行一次远程调用，然后根据这次调用的结果成功与否，转换为 CLOSED 或者 OPEN 状态，以实现断路器的弹性恢复。

#### 舱壁隔离模式

* 失败静默策略

* 防止服务雪崩，防止一个服务的异常阻塞，影响其他的服务

##### 线程池

原理：每个服务单独设立线程池，这些线程池默认不预置活动线程，只用来控制单个服务的最大连接数。譬如，对出问题的“服务 I”设置了一个最大线程数为 5 的线程池，这时候它的超时故障就只会最多阻塞 5 条用户线程，而不至于影响全局。

问题：局部线程池有一个显著的弱点，它额外增加了 CPU 的开销，每个独立的线程池都要进行排队、调度和下文切换工作。延迟加大了

##### 信号量

当服务开始调用时计数器加 1，服务返回结果后计数器减 1，一旦计数器超过设置的阈值就立即开始限流，在回落到阈值范围之前都不再允许请求了。由于不需要承担线程的排队、调度、切换工作，所以单纯维护一个作为计数器的信号量的性能损耗，相对于局部线程池来说几乎可以忽略不计。



#### 重试模式

故障转移和故障恢复策略都需要对服务进行重复调用，

需要具备幂等性

#### 



### 总结

熔断、隔离、重试、降级、超时等概念都是建立具有韧性的微服务系统的必须的保障措施。目前，这些措施的正确运作，还主要是依靠开发人员对服务逻辑的了解，以及运维人员的经验去静态调整配置参数和阈值，但是面对能够自动扩缩（Auto Scale）的大型分布式系统，静态的配置越来越难以起到良好的效果，这就**需要系统不仅要有能力自动根据服务负载来调整服务器的数量规模，同时还要有能力根据服务调用的统计的结果，或者[启发式搜索](https://en.wikipedia.org/wiki/Heuristic_(computer_science))的结果来自动变更容错策略和参数**，这方面研究现在还处于各大厂商在内部分头摸索的初级阶段，是服务治理的未来重要发展方向之一。



参考https://icyfenix.cn/distribution/traffic-management/failure.html