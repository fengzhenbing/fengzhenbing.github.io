<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="系统调用  用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。 系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。  凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。
进程的调度算法  先到先服务(FCFS)调度算法 短作业优先(SJF)的调度算法 时间片轮转调度算法 多级反馈队列调度算法 优先级调度  死锁 必要条件
  互斥：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。
  占有并等待：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。
  非抢占：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。
  循环等待：有一组等待进程 {P0, P1,..., Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，&amp;hellip;&amp;hellip;，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。
  虚拟内存 虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间。
局部性原理  时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。  "><title></title><link rel=canonical href=https://fengzhenbing.github.io/p/><link rel=stylesheet href=/scss/style.min.css><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta property="og:title" content><meta property="og:description" content="系统调用  用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。 系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。  凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。
进程的调度算法  先到先服务(FCFS)调度算法 短作业优先(SJF)的调度算法 时间片轮转调度算法 多级反馈队列调度算法 优先级调度  死锁 必要条件
  互斥：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。
  占有并等待：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。
  非抢占：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。
  循环等待：有一组等待进程 {P0, P1,..., Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，&amp;hellip;&amp;hellip;，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。
  虚拟内存 虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间。
局部性原理  时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。  "><meta property="og:url" content="https://fengzhenbing.github.io/p/"><meta property="og:site_name" content="Feng Zhenbing's Blog"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta name=twitter:title content><meta name=twitter:description content="系统调用  用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。 系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。  凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。
进程的调度算法  先到先服务(FCFS)调度算法 短作业优先(SJF)的调度算法 时间片轮转调度算法 多级反馈队列调度算法 优先级调度  死锁 必要条件
  互斥：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。
  占有并等待：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。
  非抢占：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。
  循环等待：有一组等待进程 {P0, P1,..., Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，&amp;hellip;&amp;hellip;，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。
  虚拟内存 虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间。
局部性原理  时间局部性 ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。 空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。  "></head><body class="article-page has-toc"><script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=https://fengzhenbing.github.io/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>返回</span></a></div><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><h2 class=article-title><a href=/p/></a></h2><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>阅读时长: 1 分钟</time></div><div><svg t="1631787077345" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="2237" width="48" height="48" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M512 608a96 96 0 110-192 96 96 0 010 192m0-256c-88.224.0-160 71.776-160 160s71.776 160 160 160 160-71.776 160-160-71.776-160-160-160" p-id="2238" fill="#bfbfbf"/><path d="M512 8e2c-212.064.0-384-256-384-288s171.936-288 384-288 384 256 384 288-171.936 288-384 288m0-640C265.248 160 64 443.008 64 512s201.248 352 448 352 448-283.008 448-352S758.752 160 512 160" p-id="2239" fill="#bfbfbf"/></svg><time class=article-time--reading>总阅读量:<span id=busuanzi_value_page_pv></span>次</time></div></footer></div></header><section class=article-content><p>Redis作为内存中的数据结构存储，常用作数据库、缓存和消息代理。它支持数据结构，如 字符串，散列，列表，集合，带有范围查询的排序集（sorted sets），位图（bitmaps），超级日志（hyperloglogs），具有半径查询和流的地理空间索引。Redis具有内置复制，Lua脚本，LRU驱逐，事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster自动分区。</p><p>为了实现其出色的性能，Redis使用<strong>内存数据集（in-memory dataset）</strong>。</p><p>MQ应用有很多，比如ActiveMQ,RabbitMQ,Kafka等，但是也可以基于redis来实现，可以降低系统的维护成本和实现复杂度，本篇介绍redis中实现消息队列的几种方案。</p><ul><li>基于List的 LPUSH+BRPOP 的实现</li><li>PUB/SUB，订阅/发布模式</li><li>基于Sorted-Set的实现</li><li>基于Stream类型的实现</li></ul><h3 id=基于异步消息队列list-lpush-brpoprpush-blpop>基于异步消息队列List lpush-brpop(rpush-blpop)</h3><p>使用<strong>rpush</strong>和<strong>lpush</strong>操作入队列，<strong>lpop</strong>和<strong>rpop</strong>操作出队列。</p><p><strong>List支持多个生产者和消费者并发进出消息</strong>，每个消费者拿到都是<strong>不同</strong>的列表元素。</p><p>但是当队列为空时，lpop和rpop会一直空轮训，消耗资源；所以引入阻塞读blpop和brpop（b代表blocking），阻塞读在队列没有数据的时候进入休眠状态，</p><p>一旦数据到来则立刻醒过来，消息延迟几乎为零。</p><p><strong>注意</strong></p><p>你以为上面的方案很完美？还有个问题需要解决：空闲连接的问题。</p><p>如果线程一直阻塞在那里，Redis客户端的连接就成了闲置连接，闲置过久，服务器一般会主动断开连接，减少闲置资源占用，这个时候blpop和brpop或抛出异常，</p><p>所以在编写客户端消费者的时候要小心，如果捕获到异常，还有重试。</p><p><strong>缺点：</strong></p><ul><li>做消费者确认ACK麻烦，不能保证消费者消费消息后是否成功处理的问题（宕机或处理异常等），通常需要维护一个Pending列表，保证消息处理确认。</li><li>不能做广播模式，如pub/sub，消息发布/订阅模型</li><li>不能重复消费，一旦消费就会被删除</li><li>不支持分组消费</li></ul><p>如何实现：<a class=link href="https://mp.weixin.qq.com/s?__biz=MzI2NzMyMDQ0NQ==&mid=100000206&idx=1&sn=5e18a6aa07b43b107041444499eb2c77&chksm=6a81ecdc5df665caead4c7575bbb09ff2d72040b68239581264f3cfa69723397cb0dcbc0da85#rd" target=_blank rel=noopener>Redis应用-异步消息队列与延时队列</a></p><h3 id=pubsub订阅发布模式>PUB/SUB,订阅/发布模式</h3><p>SUBSCRIBE，用于订阅信道</p><p>PUBLISH，向信道发送消息</p><p>UNSUBSCRIBE，取消订阅</p><p>此模式允许生产者只生产一次消息，由中间件负责将消息复制到多个消息队列，每个消息队列由对应的消费组消费。</p><p><strong>优点</strong></p><p>典型的广播模式，一个消息可以发布到多个消费者</p><p>多信道订阅，消费者可以同时订阅多个信道，从而接收多类消息</p><p>消息即时发送，消息不用等待消费者读取，消费者会自动接收到信道发布的消息</p><p><strong>缺点</strong></p><p>消息一旦发布，不能接收。换句话就是发布时若客户端不在线，则消息丢失，不能寻回</p><p>不能保证每个消费者接收的时间是一致的</p><p>若消费者客户端出现消息积压，到一定程度，会被强制断开，导致消息意外丢失。通常发生在消息的生产远大于消费速度时</p><p>*<strong>可见，Pub/Sub 模式不适合做消息存储，消息积压类的业务，而是擅长处理广播，即时通讯，即时反馈的业务。*</strong></p><h3 id=基于sorted-set的实现>基于Sorted-Set的实现</h3><p>Sortes Set(有序列表)，类似于java的SortedSet和HashMap的结合体，一方面她是一个set，保证内部value的唯一性，另一方面它可以给每个value赋予一个score，代表这个value的</p><p>排序权重。内部实现是“跳跃表”。</p><p>有序集合的方案是在自己确定消息顺ID时比较常用，使用集合成员的Score来作为消息ID，保证顺序，还可以保证消息ID的单调递增。通常可以使用时间戳+序号的方案。确保了消息ID的单调递增，利用SortedSet的依据</p><p>Score排序的特征，就可以制作一个有序的消息队列了。</p><p><strong>优点</strong></p><p>就是可以自定义消息ID，在消息ID有意义时，比较重要。</p><p><strong>缺点</strong></p><p>缺点也明显，不允许重复消息（因为是集合），同时消息ID确定有错误会导致消息的顺序出错。</p><h3 id=基于stream类型的实现>基于Stream类型的实现</h3><p>Redis5.0</p><p><img src=https://upload-images.jianshu.io/upload_images/19397245-2683b998ae2949c5.jpg alt=img></p><p>Stream为redis 5.0后新增的数据结构。支持多播的可持久化消息队列，实现借鉴了Kafka设计。</p><p>Redis Stream的结构如上图所示，<strong>它有一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的ID和对应的内容</strong>。<strong>消息是持久化的</strong>，Redis重启后，内容还在。</p><p>每个Stream都有唯一的名称，它就是Redis的key，在我们<strong>首次使用xadd指令追加消息时自动创建</strong>。</p><p><strong>每个Stream都可以挂多个消费组，每个消费组会有个游标last_delivered_id在Stream数组之上往前移动，表示当前消费组已经消费到哪条消息了</strong>。每个消费组都有一个Stream内唯一的名称，消费组不会自动创建，它需要单独的指令xgroup create进行创建，需要指定从Stream的某个消息ID开始消费，这个ID用来初始化last_delivered_id变量。</p><p>每个消费组(Consumer Group)的状态都是独立的，相互不受影响。也就是说<strong>同一份Stream内部的消息会被每个消费组都消费到</strong>。</p><p><strong>同一个消费组(Consumer Group)可以挂接多个消费者(Consumer)，这些消费者之间是竞争关系</strong>，任意一个消费者读取了消息都会使游标last_delivered_id往前移动。每个消费者者有一个组内唯一名称。</p><p>消费者(Consumer)内部会有个状态变量<strong>pending_ids</strong>，它记录了当前已经被客户端读取的消息，但是还没有ack。如果客户端没有ack，这个变量里面的消息ID会越来越多，一旦某个消息被ack，它就开始减少。这个pending_ids变量在Redis官方被称之为PEL，也就是Pending Entries List，这是一个很核心的数据结构，它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理。</p><p><strong>增删改查</strong></p><ul><li>xadd <strong>追加消息</strong></li><li>xdel 删除消息，这里的删除仅仅是设置了标志位，不影响消息总长度</li><li>xrange <strong>获取消息列表</strong>，会自动过滤已经删除的消息</li><li>xlen 消息长度</li><li>del 删除Stream</li></ul><p><strong>独立消费</strong></p><p>我们可以在不定义消费组的情况下进行Stream消息的独立消费，当Stream没有新消息时，甚至可以阻塞等待。Redis设计了一个单独的消费指令xread，可以将Stream当成普通的消息队列(list)来使用。使用xread时，我们可以完全忽略消费组(Consumer Group)的存在，就好比Stream就是一个普通的列表(list)。</p><p><strong>创建消费组</strong></p><p>Stream通过xgroup create指令创建消费组(Consumer Group)，需要传递起始消息ID参数用来初始化last_delivered_id变量。</p><p><strong>消费</strong></p><p>Stream提供了xreadgroup指令可以进行消费组的组内消费，需要提供消费组名称、消费者名称和起始消息ID。它同xread一样，也可以阻塞等待新消息。读到新消息后，对应的消息ID就会进入消费者的PEL(正在处理的消息)结构里，客户端处理完毕后使用xack指令通知服务器，本条消息已经处理完毕，该消息ID就会从PEL中移除。</p><p>Stream消息太多怎么办</p><p><img src=https://upload-images.jianshu.io/upload_images/19397245-f5b35dbda2281ac7.jpg alt=img></p><p>读者很容易想到，要是消息积累太多，Stream的链表岂不是很长，内容会不会爆掉就是个问题了。xdel指令又不会删除消息，它只是给消息做了个标志位。</p><p>Redis自然考虑到了这一点，所以它提供了一个定长Stream功能。在xadd的指令提供一个定长长度maxlen，就可以将老的消息干掉，确保最多不超过指定长度。</p><blockquote><p>127.0.0.1:6379> xlen codehole</p><p>(integer) 5</p><p>127.0.0.1:6379> xadd codehole maxlen 3 * name xiaorui age 1</p><p>1527855160273-0</p><p>127.0.0.1:6379> xlen codehole</p><p>(integer) 3</p></blockquote><p>我们看到Stream的长度被砍掉了。</p><p><strong>消息如果忘记ACK会怎样？</strong></p><p>Stream在每个消费者结构中保存了正在处理中的消息ID列表PEL，如果消费者收到了消息处理完了但是没有回复ack，就会导致PEL列表不断增长，如果有很多消费组的话，那么这个PEL占用的内存就会放大。</p><p><strong>PEL如何避免消息丢失？</strong></p><p>在客户端消费者读取Stream消息时，Redis服务器将消息回复给客户端的过程中，客户端突然断开了连接，消息就丢失了。但是PEL里已经保存了发出去的消息ID。待客户端重新连上之后，可以再次收到PEL中的消息ID列表。不过此时xreadgroup的起始消息必须是任意有效的消息ID，一般将参数设为0-0，表示读取所有的PEL消息以及自last_delivered_id之后的新消息。</p><p><strong>分区Partition</strong></p><p>Redis没有原生支持分区的能力，想要使用分区，需要分配多个Stream，然后在客户端使用一定的策略来讲消息放入不同的stream。</p><p><strong>结论</strong></p><p>Stream的消费模型借鉴了kafka的消费分组的概念，它弥补了Redis Pub/Sub不能持久化消息的缺陷。但是它又不同于kafka，kafka的消息可以分partition，而Stream不行。如果非要分parition的话，得在客户端做，提供不同的Stream名称，对消息进行hash取模来选择往哪个Stream里塞。如果读者稍微研究过Redis作者的另一个开源项目Disque的话，这极可能是作者意识到Disque项目的活跃程度不够，所以将Disque的内容移植到了Redis里面。</p><p>参考文章：</p><p><a href=https://www.cnblogs.com/-wenli/p/12777703.html>https://www.cnblogs.com/-wenli/p/12777703.html</a></p><p><a class=link href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fenmotech%2Farticle%2Fdetails%2F81230531" target=_blank rel=noopener>https://blog.csdn.net/enmotech/article/details/81230531</a></p><p><a class=link href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.hellokang.net%2Fredis%2Fmessage-queue-by-redis.html" target=_blank rel=noopener>http://www.hellokang.net/redis/message-queue-by-redis.html</a></p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper></aside><script src=https://utteranc.es/client.js repo=fengzhenbing/fengzhenbing.github.io issue-term=pathname label=Comment crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>function setUtterancesTheme(b){let a=document.querySelector('.utterances iframe');a&&a.contentWindow.postMessage({type:'set-theme',theme:`github-${b}`},'https://utteranc.es')}addEventListener('message',a=>{if(a.origin!=='https://utteranc.es')return;setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener('onColorSchemeChange',a=>{setUtterancesTheme(a.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2021 Feng Zhenbing's Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.1.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section><span id=busuanzi_container_site_pv>本站访问量：<span id=busuanzi_value_site_pv></span>次</span>
&nbsp;
<span id=busuanzi_container_site_uv>您是本站第 <span id=busuanzi_value_site_uv></span>位访问者</span></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><ol><li><a href=#基于异步消息队列list-lpush-brpoprpush-blpop>基于异步消息队列List lpush-brpop(rpush-blpop)</a></li><li><a href=#pubsub订阅发布模式>PUB/SUB,订阅/发布模式</a></li><li><a href=#基于sorted-set的实现>基于Sorted-Set的实现</a></li><li><a href=#基于stream类型的实现>基于Stream类型的实现</a></li></ol></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script></body></html>