<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>锁 on Feng Zhenbing's Blog</title><link>https://fengzhenbing.github.io/tags/%E9%94%81/</link><description>Recent content in 锁 on Feng Zhenbing's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 15 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://fengzhenbing.github.io/tags/%E9%94%81/index.xml" rel="self" type="application/rss+xml"/><item><title>Synchronized锁</title><link>https://fengzhenbing.github.io/p/synchronized%E9%94%81/</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://fengzhenbing.github.io/p/synchronized%E9%94%81/</guid><description>Synchronized Object.wait()：释放当前对象锁，并进入阻塞队列(wait set) Object.notify()：唤醒当前对象阻塞队列(wait set)里的任一线程（并不保证唤醒哪一个） Object.notifyAll()：唤醒当前对象阻塞队列(wait set)里的所有线程, 进到entry set 去竞争锁 为什么wait,notify和notifyAll要与synchronized一起使用？ Wait 只有通过synchronized拿到锁，才能进入wait set
notify notifyAll只有通过synchronized拿到锁，才能去唤醒 wait set 里线程 到entry set
object monitor 对象在内存中的存储 Markword 32位jvm 结构如下： 重量级锁即为 Synchronized 的锁
锁升级 参考 https://mp.weixin.qq.com/s/2yxexZUr5MWdMZ02GCSwdA</description></item></channel></rss>